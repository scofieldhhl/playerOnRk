package org.app.enjoy.music.util;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import android.content.Context;import android.graphics.Bitmap;import android.os.Handler;import android.os.Message;import android.support.v4.util.LruCache;import android.text.TextUtils;public class ImageDownLoader {	private String TAG = "ImageDownLoader";	private Context mContext;	/**	 * 缓存Image的类，当存储Image的大小大于LruCache设定的值，系统自动释放内存	 */	private LruCache<String, Bitmap> mMemoryCache;	/**	 * 下载Image的线程池	 */	private ExecutorService mImageThreadPool = null;	public ImageDownLoader(Context context){		mContext = context;		//获取系统分配给每个应用程序的最大内存，每个应用系统分配32M		int maxMemory = (int) Runtime.getRuntime().maxMemory();		int mCacheSize = maxMemory / 8;		//给LruCache分配1/8 4M		mMemoryCache = new LruCache<String, Bitmap>(mCacheSize){			//必须重写此方法，来测量Bitmap的大小			@Override			protected int sizeOf(String key, Bitmap value) {				return value.getRowBytes() * value.getHeight();			}		};	}	/**	 * 获取线程池的方法，因为涉及到并发的问题，我们加上同步锁	 * @return	 */	public ExecutorService getThreadPool(){		if(mImageThreadPool == null){			synchronized(ExecutorService.class){				if(mImageThreadPool == null){					mImageThreadPool = Executors.newFixedThreadPool(2);				}			}		}		return mImageThreadPool;	}	/**	 * 添加Bitmap到内存缓存	 * @param key	 * @param bitmap	 */	public void addBitmapToMemoryCache(String key, Bitmap bitmap) {		if (getBitmapFromMemCache(key) == null && bitmap != null) {			mMemoryCache.put(key, bitmap);		}	}	/**	 * 从内存缓存中获取一个Bitmap	 * @param key	 * @return	 */	public Bitmap getBitmapFromMemCache(String key) {		if (!TextUtils.isEmpty(key)) {			if (!key.toLowerCase().equals("null")) {				return mMemoryCache.get(key);			}		}		return null;	}	/**	 * 先从内存缓存中获取Bitmap,如果没有就从媒体库获取	 * 没有就去下载	 * @param albumId	 * @param listener	 * @return	 */	public Bitmap getAlbumImage(Context context,final long id,final String albumId, final onImageLoaderListener listener){		Bitmap bitmap = showCacheBitmap(albumId);		if (bitmap != null){			return bitmap;		} else {			final Handler handler = new Handler(){				@Override				public void handleMessage(Message msg) {					super.handleMessage(msg);					listener.onImageLoader((Bitmap)msg.obj);				}			};			getThreadPool().execute(new Runnable() {				@Override				public void run() {					if (!TextUtils.isEmpty(albumId)) {						if (!albumId.toLowerCase().equals("null")) {							/*Bitmap bitmap = AlbumImgUtil.getArtwork(mContext,id,Long.parseLong(albumId),false);							Message msg = handler.obtainMessage();							msg.obj = bitmap;							handler.sendMessage(msg);							//将Bitmap 加入内存缓存							addBitmapToMemoryCache(String.valueOf(albumId), bitmap);*/						}					}				}			});		}		return bitmap;	}	public Bitmap getAlbumImage(Context context,final long id,final String albumId){		Bitmap bitmap = showCacheBitmap(albumId);		if (bitmap != null){			return bitmap;		} else {			getThreadPool().execute(new Runnable() {				@Override				public void run() {					/*if (!TextUtils.isEmpty(albumId)) {						if (!albumId.toLowerCase().equals("null")) {							Bitmap bitmap = AlbumImgUtil.getArtwork(mContext,id,Long.parseLong(albumId),false);							//将Bitmap 加入内存缓存							addBitmapToMemoryCache(String.valueOf(albumId), bitmap);						}					}*/				}			});		}		return null;	}	/**	 * 从内存中获取Bitmap	 * @param url	 * @return	 */	public Bitmap showCacheBitmap(String url){		if(getBitmapFromMemCache(url) != null){			return getBitmapFromMemCache(url);		}		return null;	}	/**	 * 取消正在下载的任务	 */	public synchronized void cancelTask() {		if(mImageThreadPool != null){			mImageThreadPool.shutdownNow();			mImageThreadPool = null;		}	}	/**	 * 异步下载图片的回调接口	 * @author len	 *	 */	public interface onImageLoaderListener{		void onImageLoader(Bitmap bitmap);	}}